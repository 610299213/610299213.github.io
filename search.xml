<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM调优</title>
      <link href="/2022/08/19/jvmOpt/"/>
      <url>/2022/08/19/jvmOpt/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="记录一次JVM调优"><a href="#记录一次JVM调优" class="headerlink" title="记录一次JVM调优"></a>记录一次JVM调优</h1><hr><h2 id="调优前准备"><a href="#调优前准备" class="headerlink" title="调优前准备"></a>调优前准备</h2><h3 id="使用jps查看所要查询的对应java虚拟机进程"><a href="#使用jps查看所要查询的对应java虚拟机进程" class="headerlink" title="使用jps查看所要查询的对应java虚拟机进程"></a>使用jps查看所要查询的对应java虚拟机进程</h3><p>在JVM调优之前我们首先要知道一些常用命令:<br>Jps(Java Virtual Machine Process Status Tool)是JDK提供的一个可以列出正在运行的Java虚拟机的进程信息的命令行工具。</p><ul><li>jps<ul><li>m:显示启动时候传递给main方法的参数</li><li>l:显示完全的包名（jar文件会执行其路径的位置）</li><li>v:显示启动时传递虚拟机的参数</li><li>以上参数可以组合 如 -mlv<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jps</span><br><span class="line">---------------------------</span><br><span class="line"><span class="comment"># 本机的结果如下| pid / name |下面就是本机运行的Java虚拟机|</span></span><br><span class="line">373380 Jps</span><br><span class="line">326630 RemoteMavenServer36</span><br><span class="line">4819 NutstoreGUI</span><br><span class="line">373091 BolgApp</span><br><span class="line">325986 Main</span><br><span class="line">373080 Launcher</span><br><span class="line">341626 JConsole</span><br></pre></td></tr></table></figure>我们需要查看的是 BlogApp 这个所对应的进程 373091。</li></ul></li></ul><h3 id="JVM常用的参数"><a href="#JVM常用的参数" class="headerlink" title="JVM常用的参数"></a>JVM常用的参数</h3><ol><li><p>堆设置</p><ul><li><p>Xms:初始堆大小 (-XX:InitialHeapSize)</p></li><li><p>Xmx:最大堆大小 (-XX:MaxHeapSize)</p></li><li><p>Xmn:新生代大小 (-XX:MaxNewSize)</p></li><li><p>XX:NewRatio:新生代和老年代的比值(-XX:NewRatio&#x3D;2代表 新生代:老年代&#x3D;1:2 &#x2F; 新生代占堆内存的1&#x2F;3老年代占2、3)</p></li><li><p>XX:SurvivorRatio:新生代中与整个幸存者区(s0和s1)的比值。XX:SurvivorRatio&#x3D;3，表示新生代Eden和幸存者区&#x3D;3:1，一个Survivor区占整个新生代的1&#x2F;4 默认值是8。(如果Eden区域设置的太大 新生的对象都会分配在这里 如果Eden区域满了就会触发minorGc,理想的情况下是全部回收完毕但是如果servivor区域过小可能导致无法容下那些未被回收完毕的,就导致幸存对象在一次或者极少次数的Gc后移动到老年代,这样说来就失去了设置minorGc的初衷,如果Eden区设置的太小那么新产生的对象会迅速的将Eden区占满就是增加了minorGc的次数,stp时间变长降低的虚拟机的性能)<br> -XX:MaxTenuringThreshold:设置转入老年代的存活次数。如果是0，则直接跳过新生代进入老年代(该参数用于控制对象经过GC多少次仍然存活后晋升到老年代的最大阈值，参数最大可配置为15，即对象最多经过15次GC后仍然存活就会晋升到老年代,实际上不一定会经过15次才能晋升！这个值的JVM内部会进行动态计算然后动态改变的。)</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Desired survivor size 184549376 bytes, new threshold 1 (max 15)</span><br><span class="line">- age   1:        369096960 bytes,        369096960 total</span><br><span class="line">下面进行GC，年轻代有很多对象全跑到了老年代</span><br><span class="line"></span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 源码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ageTable::compute_tenuring_threshold</span><span class="params">(<span class="type">size_t</span> survivor_capacity)</span> &#123;</span><br><span class="line"><span class="comment">//TargetSurvivorRatio默认为50</span></span><br><span class="line"><span class="comment">//desired_survivor_size = survivor的空间*50%</span></span><br><span class="line"><span class="type">size_t</span> desired_survivor_size = (<span class="type">size_t</span>)((((<span class="type">double</span>) survivor_capacity)*TargetSurvivorRatio)/<span class="number">100</span>);</span><br><span class="line"><span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> age = <span class="number">1</span>;</span><br><span class="line">assert(sizes[<span class="number">0</span>] == <span class="number">0</span>, <span class="string">&quot;no objects with age zero should be recorded&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (age &lt; table_size) &#123;</span><br><span class="line">    <span class="comment">// 循环遍历所有年龄代的对象累加得到一个大小</span></span><br><span class="line">    total += sizes[age];</span><br><span class="line">    <span class="comment">// 如果该大小大于desired_survivor_size，即survivor的空间*50%，那么退出循环</span></span><br><span class="line">    <span class="keyword">if</span> (total &gt; desired_survivor_size) <span class="keyword">break</span>;</span><br><span class="line">    age++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果算出来的age大于MaxTenuringThreshold则使用MaxTenuringThreshold，否则使用计算出来的age</span></span><br><span class="line"><span class="type">int</span> result = age &lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (PrintTenuringDistribution || UsePerfData) &#123;</span><br><span class="line">    <span class="keyword">if</span> (PrintTenuringDistribution) &#123;</span><br><span class="line">    gclog_or_tty-&gt;cr();</span><br><span class="line">    <span class="comment">// 这里就是线上出现的那个日志所在的地方</span></span><br><span class="line">    gclog_or_tty-&gt;print_cr(<span class="string">&quot;Desired survivor size %ld bytes, new threshold %d (max %d)&quot;</span>,</span><br><span class="line">        desired_survivor_size*oopSize, result, MaxTenuringThreshold);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// 返回计算的年龄</span></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 经过多次GC，存活的对象会在From和To两个地方来回的存放，而前提是两个空间能有足够的大小去存放这些数据，上述算法中，会计算每个年龄的大小，如果达到某个年龄后发现总大小以及大于Survivor的大小的50%，那么这时候就需要调整阈值，不能继续等到15次GC后才晋升，这样会导致Survivor的空间不足，所以调整阈值，让其尽快晋升<br> 回到线上的那个例子，线上我记得是没配置TargetSurvivorRatio属性，那么按照50%算，survivor * 50%&#x3D;184549376，在while循环中计算第一个年龄代&#x3D;369096960&gt;184549376，那么退出循环，此时计算得到的年龄为1，所以这个年龄的对象会提前晋升</p></li><li><p>XX:PermSize、-XX:MaxPermSize:分别设置永久代最小大小与最大大小（Java8以前）</p></li><li><p>XX:MetaspaceSize、-XX:MaxMetaspaceSize:分别设置元空间最小大小与最大大小（Java8以后）</p></li></ul></li><li><p>收集器设置</p><ul><li>XX:+UseSerialGC:设置串行收集器(使用串行回收器进行回收，这个参数会使新生代和老年代都使用串行回收器，新生代使用复制算法，老年代使用标记-整理算法。Serial收集器是最基本、历史最悠久的收集器，它是一个单线程收集器。一旦回收器开始运行时，整个系统都要停止。)</li><li>XX:+UseParallelGC:设置并行收集器<ul><li>代表新生代使用Parallel收集器，老年代使用串行收集器。Parallel Scavenge收集器在各个方面都很类似ParNew收集器，它的目的是达到一个可以控制的吞吐量。吞吐量为CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间），虚拟机运行100分钟，垃圾收集花费1分钟，那吞吐量就99%。Server模式默认开启，其他模式默认关闭。</li><li>Parallel Scavenge提供了两个参数用于控制吞吐量，-XX:MaxGCPauseMillis参数用于设置最大停顿时间，它的参数运行值是一个大于0的毫秒数，收集器将尽力保证垃圾回收时间不超过设定值，系统运行的需要回收的垃圾总量是固定的，缩短停顿时间的同时会增大回收频度。-XX:GCTimeRatio参数用户控制垃圾回收时间占比，它运行的参数值是0-100的整数，如果参数设置为19，代表最大GC时间占总时间的5%（1&#x2F;(1+19)）。</li><li>Parallel收集器还提供了自适应的调节策略-XX:UseAdaptiveSizePolicy，即JVM会根据实际运行情况动态调整新生代大小、新生代和s区比例、晋升老年代对象大小等细节参数。</li></ul></li><li>XX:+UseParalledlOldGC:设置并行老年代收集器(新生代和老年代都使用并行收集器。打印出的GC会带PSYoungGen、ParOldGen关键字。)</li><li>XX:+UseConcMarkSweepGC:设置并发收集器<ul><li>Concurrent Mark Sweep 并发标记清除，即使用CMS收集器。它是和应用程序线程一起执行，相对于Stop The World来说虚拟机停顿时间较少。停顿减少，吞吐量会降低。它使用的是 标记清除算法，运作过程为四个步骤，分别是 初始标记—并发标识—重新标记—并发清除。它是老年代的收集算法，新生代使用ParNew收集算法。默认关闭</li><li>CMS收集器的缺点是对服务器CPU资源较为敏感，在并发标记时会降低吞吐量。它使用的标记清除算法也会产生大量空间碎片，空间碎片的存在会加大Full GC的频率，虽然老年代还有足够的内存，但是因为内存空间连续，不得不进行Full GC。</li></ul></li></ul></li><li><p>垃圾回收统计信息 &#x2F; 打印垃圾回收信息</p><ul><li>XX:+PrintGC</li><li>XX:+PrintGCDetails</li><li>XX:+PrintGCTimeStamps</li><li>Xloggc:filename</li></ul></li><li><p>并行收集器设置</p><ul><li>XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数。</li><li>XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大暂停时间</li><li>XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为1&#x2F;(1+n)</li></ul></li><li><p>并发收集器设置</p><ul><li>XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。</li><li>XX:ParallelGCThreads&#x3D;n:设置并发收集器新生代收集方式为并行收集时，使用的CPU数。并行收集线程数。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题</title>
      <link href="/2022/08/17/leetCode/"/>
      <url>/2022/08/17/leetCode/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script>    <div id="aplayer-ylcpmpty" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="000PeZCQ1i4XVs" data-server="tencent" data-type="artist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#3F51B5"    ></div><h1 id="LeetCode刷题"><a href="#LeetCode刷题" class="headerlink" title="LeetCode刷题"></a>LeetCode刷题</h1><hr><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><hr><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><ol><li><p><a href="https://leetcode.cn/problems/binary-search">查找元素在数组中的位置</a>:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</span><br><span class="line"></span><br><span class="line">Demo 1:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="line">输出: 4</span><br><span class="line">解释: 9 出现在 nums 中并且下标为 4</span><br><span class="line"></span><br><span class="line">Demo 2:</span><br><span class="line">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="line">输出: -1</span><br><span class="line">解释: 2 不存在 nums 中因此返回 -1</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="comment">// 在使用二分法的时候一定是有序的数组,无序不可用!</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里使用while循环</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 二分-这么写的目的是尽可能使两数之和不超过int最大值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j - i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 中间数大于目标值 说明在左半部分</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 中间值小于目标值 说明在右半部分</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 找到后返回</span></span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到 i&gt;j或者 j&lt;i这个时候返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/search-insert-position/">搜索插入位置</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span><br><span class="line"></span><br><span class="line">请必须使用时间复杂度为 O(log n) 的算法。</span><br><span class="line"></span><br><span class="line">demo1:</span><br><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">demo2:</span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">demo3:</span><br><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先 看到有序以及 时间复杂度的限定基本是二分法跑不了了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 右边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j - i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target)&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 因为在条件不成立的时候最终的 搜索一个不存在于数组的元素时，最后一步一定是:mid=i=j, 这个i+1就是这个元素应该出现的位置</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</span><br><span class="line"></span><br><span class="line">如果数组中不存在目标值 target，返回 [-1, -1]。</span><br><span class="line"></span><br><span class="line">你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</span><br><span class="line"></span><br><span class="line">demo1:</span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br><span class="line"></span><br><span class="line">demo2:</span><br><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br><span class="line">demo3:</span><br><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br><span class="line"></span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tips:</span><br><span class="line">0 &lt;= nums.length &lt;= 105</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">nums 是一个非递减数组</span><br><span class="line">-109 &lt;= target &lt;= 109</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这个题我们可以使用两次二分查找  分别查找上边界和下边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] result = &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果数组中没有元素直接就是返回&#123;-1, -1&#125;。这个是一个陷阱</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == nums.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result[<span class="number">0</span>] = binarySearch(nums, target, <span class="literal">true</span>);</span><br><span class="line">        result[<span class="number">1</span>] = binarySearch(nums, target, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找,返回查找的位置</span></span><br><span class="line">    <span class="comment">// isLeft: 查找的是否是左边界?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">boolean</span> isLeft)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还是和之前写法一样</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j - i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果正常的二分法到这里就结束了,但是这里target可能有多个</span></span><br><span class="line">                <span class="comment">// 本题又是找边界的,所以为了方便在这个里面这么写了一下</span></span><br><span class="line">                <span class="comment">// 这里的res始终记下最后一次匹配到的位置</span></span><br><span class="line">                res = mid;</span><br><span class="line">                <span class="keyword">if</span> (isLeft)&#123;</span><br><span class="line">                    j = mid - <span class="number">1</span>; </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    i = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/sqrtx/">x的平方根</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</span><br><span class="line"></span><br><span class="line">由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</span><br><span class="line"></span><br><span class="line">注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</span><br><span class="line"></span><br><span class="line">demo1:</span><br><span class="line">输入：x = 4</span><br><span class="line">输出：2</span><br><span class="line"></span><br><span class="line">demo2:</span><br><span class="line">输入：x = 8</span><br><span class="line">输出：2</span><br><span class="line">解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。</span><br><span class="line"></span><br><span class="line">tips:</span><br><span class="line">0 &lt;= x &lt;= 231 - 1</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果使用暴力法直接超时</span></span><br><span class="line"><span class="comment">// 这个一看暂时无法下手,但是使用二分法的方法就可以解决</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j - i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这里需要的注意的是 可能超出int的范围 因为是平方</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid  &gt; x)&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid &lt; x)&#123;</span><br><span class="line">                i = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 之所以返回j是因为题目说了除去小数的部分。满足条件后应该是返回j</span></span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://leetcode.cn/problems/valid-perfect-square/">有效的完全平方数</a></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</span><br><span class="line"></span><br><span class="line">进阶：不要 使用任何内置的库函数，如  sqrt 。</span><br><span class="line"></span><br><span class="line">demo1:</span><br><span class="line">输入：num = 16 ,输出：true</span><br><span class="line">demo2:</span><br><span class="line">输入：num = 14, 输出：false</span><br><span class="line"></span><br><span class="line">tips: 1 &lt;= num &lt;= 2^31 - 1</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 联想到上一题肯定是二分法 不然超时</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> i + (j - i &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 还是注意超过int范围的问题</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid &gt; num)&#123;</span><br><span class="line">                j = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="type">long</span>)mid * mid &lt; num) &#123;</span><br><span class="line">                i = mid + <span class="number">1</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
